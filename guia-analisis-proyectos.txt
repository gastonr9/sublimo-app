3. Componentes y pÃ¡ginas

Ver cÃ³mo estÃ¡n organizados los componentes, vistas o rutas:

QuÃ© pantallas hay (/pages o /routes).

QuÃ© componentes se repiten (por ejemplo Navbar, Dashboard, MockupGenerator, etc.).

CÃ³mo navega el usuario entre secciones (Router o Layouts).

Esto permite derivar los requerimientos funcionales de interfaz (lo que el usuario puede hacer y ver).

ğŸ”’ 4. Contextos, hooks y estados

Revisar:

Archivos de contexto global (AuthContext, ThemeContext, UserContext, etc.).

Hooks personalizados.

CÃ³mo se maneja el estado global (Context, Redux, Zustand, etc.).

Esto revela quÃ© roles hay, quÃ© permisos existen, quÃ© flujo de datos hay y quÃ© funciones internas maneja el sistema.

ğŸ§  5. Servicios y lÃ³gica de negocio

Carpeta /services o /api â†’ saber si consume un backend y cÃ³mo.

Carpeta /utils â†’ funciones auxiliares o cÃ¡lculos que definen procesos.

Carpeta /controllers o /routes (si hay backend) â†’ para entender las acciones disponibles (guardar, eliminar, autenticar, etc.).

De ahÃ­ salen los requerimientos funcionales de backend o procesos.

ğŸ—‚ï¸ 6. Modelos o base de datos (si hay)

Archivos como models/, schema/ o db.js.

Ver quÃ© entidades maneja (por ejemplo: users, products, designs, tickets, etc.).

Ver relaciones entre esas entidades.

Esto define los requerimientos de datos (quÃ© informaciÃ³n guarda, cÃ³mo se relaciona, quÃ© se puede modificar).

ğŸ§¾ 7. Archivos estÃ¡ticos o de recursos

Carpeta /assets, /images, /mockups, /uploads.

Me dirÃ­a quÃ© tipo de archivos maneja el sistema (por ejemplo imÃ¡genes, modelos 3D, texturas, etc.) y su flujo (subida, descarga, visualizaciÃ³n).

ğŸ”„ 8. Funcionalidades especÃ­ficas o lÃ³gicas personalizadas

Buscar componentes clave (como Canvas3D, FabricCanvas, TicketResumen, etc.).

Ver interacciones: subida de archivos, impresiÃ³n de tickets, login, etc.

AhÃ­ se extraen los casos de uso concretos, lo que ayuda a escribir los requerimientos detallados (por actor y por acciÃ³n).

ğŸ“‘ 9. CÃ³digo comentado o TODOs

Muchos proyectos tienen comentarios tipo // TODO: agregar validaciÃ³n de stock, // pendiente conectar con API.
Eso permite reconocer requerimientos pendientes o planeados.

ğŸ§© 10. Dependencias y librerÃ­as usadas

Revisar librerÃ­as en package.json (por ejemplo):

@react-three/fiber, three, fabric, axios, react-router-dom, etc.
Cada una me indica una funcionalidad implÃ­cita (3D, canvas, API, routingâ€¦).
