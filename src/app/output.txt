// Contenido de: ./layout.tsx

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import Navbar from "./components/common/Navbar";
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Navbar></Navbar>

        {children}
      </body>
    </html>
  );
}


// Contenido de: ./components/sublimo/Canvas3D.tsx

"use client";

import { useEffect, useRef, useState, Suspense } from "react";
import { Canvas } from "@react-three/fiber";
import { Environment, OrbitControls, useGLTF } from "@react-three/drei";
import * as THREE from "three";
import Canvas2D from "./Canvas2D";

// Definir interfaces para las props
interface ColorPickerProps {
  selectedColor: string;
  setSelectedColor: (color: string) => void;
  label: string;
}

interface SidebarProps {
  selectedColor: string;
  setSelectedColor: (color: string) => void;
  backgroundColor: string;
  setBackgroundColor: (color: string) => void;
  onOpenCanvas2D: () => void;
}

interface ModelProps {
  modelPath?: string;
  color: string;
  textureUrl?: string;
}

// Componente ColorPicker
const ColorPicker = ({
  selectedColor,
  setSelectedColor,
  label,
}: ColorPickerProps) => (
  <div className="flex flex-col items-start gap-2">
    <label htmlFor={label} className="font-medium">
      {label}
    </label>
    <input
      id={label}
      type="color"
      value={selectedColor}
      onChange={(e) => setSelectedColor(e.target.value)}
      className="w-10 h-10 border-none outline-none cursor-pointer colores"
    />
  </div>
);

// Componente Sidebar
const Sidebar = ({
  selectedColor,
  setSelectedColor,
  backgroundColor,
  setBackgroundColor,
  onOpenCanvas2D,
  canvasDownloader,
}: SidebarProps & { canvasDownloader: () => void }) => (
  <aside className="fixed top-[120px] left-0 w-60 p-4 bg-white shadow-lg z-50 space-y-6 rounded-2xl">
    <h2 className="text-xl font-bold">Personalización</h2>
    <ColorPicker
      selectedColor={selectedColor}
      setSelectedColor={setSelectedColor}
      label="Color de la prenda"
    />
    <ColorPicker
      selectedColor={backgroundColor}
      setSelectedColor={setBackgroundColor}
      label="Color del fondo"
    />
    <button onClick={onOpenCanvas2D} className="slot w-full">
      Importar Estampa
    </button>
    <button onClick={canvasDownloader} className="slot w-full">
      Exportar
    </button>
  </aside>
);

// Componente Model
const Model = ({
  modelPath = "assets/models/tshirt.glb",
  color,
  textureUrl,
}: ModelProps) => {
  const { scene } = useGLTF(modelPath);
  const fabricTexture = useLoader(
    THREE.TextureLoader,
    "assets/models/blanco.jpg"
  );
  const overlayTexture = textureUrl
    ? useLoader(THREE.TextureLoader, textureUrl)
    : null;

  // Configurar texturas
  if (fabricTexture) {
    fabricTexture.needsUpdate = true;
    fabricTexture.format = THREE.RGBAFormat;
  }
  if (overlayTexture) {
    overlayTexture.needsUpdate = true;
    overlayTexture.format = THREE.RGBAFormat;
    overlayTexture.repeat.y = -1;
    overlayTexture.offset.y = 1;
  }

  // Buscar el mesh principal
  let mainMesh: THREE.Mesh | null = null;
  scene.traverse((child) => {
    if (mainMesh) return;
    if (child instanceof THREE.Mesh) mainMesh = child;
  });

  // Crear materiales
  const baseMaterial = new THREE.MeshStandardMaterial({
    color,
    map: fabricTexture,
    side: THREE.DoubleSide,
  });
  const overlayMaterial = overlayTexture
    ? new THREE.MeshStandardMaterial({
        map: overlayTexture,
        transparent: true,
        opacity: 1,
        depthWrite: false,
        color: 0xffffff,
        metalness: 0,
        roughness: 1,
      })
    : null;

  return (
    <group scale={5} position={[0, 0, 0]}>
      {mainMesh && (
        <>
          <mesh geometry={mainMesh.geometry} material={baseMaterial} />
          {overlayMaterial && (
            <mesh geometry={mainMesh.geometry} material={overlayMaterial} />
          )}
        </>
      )}
      {scene.children
        .filter((child) => child !== mainMesh)
        .map((child, i) => (
          <primitive key={i} object={child} />
        ))}
    </group>
  );
};

// Componente principal
export default function Canvas3D({ modelPath }: { modelPath?: string }) {
  const [selectedColor, setSelectedColor] = useState("#ffffff");
  const [backgroundColor, setBackgroundColor] = useState("#0db4e7");
  const [showCanvas2D, setShowCanvas2D] = useState(false);
  const [canvas2DTexture, setCanvas2DTexture] = useState<string | undefined>(
    undefined
  );
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);

  const canvasDownloader = () => {
    if (!rendererRef.current) return;
    const dataURL = rendererRef.current.domElement.toDataURL("image/png");
    const link = document.createElement("a");
    link.download = "captura.png";
    link.href = dataURL;
    link.click();
  };

  useEffect(() => {
    if (rendererRef.current) {
      rendererRef.current.setClearColor(new THREE.Color(backgroundColor));
    }
  }, [backgroundColor]);

  return (
    <div className="relative w-full h-screen">
      <Sidebar
        selectedColor={selectedColor}
        setSelectedColor={setSelectedColor}
        backgroundColor={backgroundColor}
        setBackgroundColor={setBackgroundColor}
        onOpenCanvas2D={() => setShowCanvas2D(true)}
        canvasDownloader={canvasDownloader}
      />
      {showCanvas2D && (
        <div className="fixed bottom-4 right-4 w-96 h-96 bg-gray-800 shadow-2xl z-40 flex flex-col rounded-lg border">
          <div className="flex items-center p-3 border-b bg-gray-50 rounded-t-lg">
            <h3 className="font-semibold flex-1 text-center">
              GUÍA DE POSICIÓN
            </h3>
            <button
              onClick={() => setShowCanvas2D(false)}
              className="text-gray-500 hover:text-gray-700 text-lg font-bold"
            >
              ×
            </button>
          </div>
          <div className="relative rounded-b-lg">
            <Canvas2D onImageChange={setCanvas2DTexture} />
          </div>
        </div>
      )}
      <Canvas
        dpr={[1, 2]}
        shadows
        camera={{ fov: 50 }}
        gl={{
          preserveDrawingBuffer: true,
          alpha: false,
        }}
        onCreated={({ gl }) => {
          rendererRef.current = gl;
          gl.setClearColor(new THREE.Color(backgroundColor));
        }}
        style={{ width: "100%", height: "100%" }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} />
        <Suspense fallback={null}>
          <Model
            modelPath={modelPath}
            color={selectedColor}
            textureUrl={canvas2DTexture}
          />
          <OrbitControls />
          <Environment preset="city" />
        </Suspense>
      </Canvas>
    </div>
  );
}


// Contenido de: ./components/sublimo/Canvas2D.tsx

"use client";

import { type ChangeEvent, useEffect, useRef } from "react";
import { FabricJSCanvas, useFabricJSEditor } from "fabricjs-react";
import * as fabric from "fabric";

function Canvas2D({
  onImageChange,
}: {
  onImageChange?: (dataUrl: string) => void;
}) {
  // Tamaño visual del canvas
  const CANVAS_SIZE = 350;
  // Tamaño de exportación de la textura
  const EXPORT_SIZE = 4096;

  const inputRef = useRef<HTMLInputElement>(null);

  const { editor, onReady } = useFabricJSEditor();
  const tshirtImgUrl = `${import.meta.env.BASE_URL}models/tshirt.jpg`;

  // Notifica al padre cuando el canvas cambia
  useEffect(() => {
    if (!editor?.canvas || !onImageChange) return;
    const handler = () => {
      const dataURL = editor.canvas.toDataURL({
        format: "png",
        multiplier: EXPORT_SIZE / CANVAS_SIZE,
      });
      onImageChange(dataURL);
    };
    editor.canvas.on("object:added", handler);
    editor.canvas.on("object:modified", handler);
    editor.canvas.on("object:removed", handler);
    return () => {
      editor.canvas.off("object:added", handler);
      editor.canvas.off("object:modified", handler);
      editor.canvas.off("object:removed", handler);
    };
  }, [editor, onImageChange]);

  const handlePic = (event: ChangeEvent<HTMLInputElement>) => {
    if (!event.target.files) return;
    const file = event.target.files[0];
    const url = URL.createObjectURL(file);
    fabric.Image.fromURL(url, (oImg: any) => {
      oImg.scale(0.1).set("flipY", false);
      editor?.canvas.add(oImg);
      // Notifica al padre inmediatamente después de agregar la imagen
      setTimeout(() => {
        if (editor?.canvas && onImageChange) {
          const dataUrl = editor.canvas.toDataURL({ format: "png" });
          onImageChange(dataUrl);
        }
      }, 100);
    });
  };

  return (
    <div className="flex flex-col h-full w-full p-2  items-center justify-center">
      <button
        onClick={() => inputRef.current?.click()}
        className="py-1 px-3 bg-yellow-500 text-white rounded-lg m-2 text-sm"
        children="Subir archivo"
      />
      <input
        ref={inputRef}
        onChange={handlePic}
        type="file"
        className="hidden"
      />
      <div
        className="justify-items-center rounded-xl border-4 border-yellow-500"
        style={{
          width: CANVAS_SIZE,
          height: CANVAS_SIZE,
          backgroundImage: `url(${tshirtImgUrl})`,
          backgroundSize: "cover",
          backgroundPosition: "center",
          backgroundRepeat: "no-repeat",
          position: "relative",
        }}
      >
        <div style={{ position: "absolute", inset: 0 }}>
          <FabricJSCanvas
            onReady={onReady}
            className="w-full h-full bg-transparent"
          />
        </div>
      </div>
    </div>
  );
}

export default Canvas2D;


// Contenido de: ../../package.json

{
  "name": "sublimo-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@react-three/drei": "^9.122.0",
    "@react-three/fiber": "^8.17.10",
    "@supabase/supabase-js": "^2.55.0",
    "@vercel/node": "^5.3.20",
    "fabric": "^5.3.0",
    "fabricjs-react": "^1.2.2",
    "next": "15.5.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router": "^7.6.2",
    "react-router-dom": "^7.6.2",
    "sharp": "^0.34.3",
    "three": "^0.179.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/fabric": "^5.3.10",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


